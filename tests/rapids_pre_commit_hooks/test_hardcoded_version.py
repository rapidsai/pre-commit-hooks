# SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION.
# SPDX-License-Identifier: Apache-2.0

import contextlib
from unittest.mock import Mock, patch

import pytest

from rapids_pre_commit_hooks import hardcoded_version
from rapids_pre_commit_hooks.lint import Lines, LintWarning, Linter, Note
from rapids_pre_commit_hooks_test_utils import parse_named_ranges


@pytest.mark.parametrize(
    ["content"],
    [
        pytest.param(
            """\
            + [project]
            + dependencies = [
            :                >0
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            :  !0
            """,
            id="project-dependencies",
        ),
        pytest.param(
            """\
            + [project.optional-dependencies]
            + test = [
            : >0
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            + cuda = [
            +     "dep-c",
            +     "dep-d",
            + ] # Automatically generated by rapids-dependency-file-generator
            :                                                                 !0
            """,  # noqa: E501
            id="project-optional-dependencies",
        ),
        pytest.param(
            """\
            + [build-system]
            + requires = [
            :            >0
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            :  !0
            """,
            id="build-system-requires",
        ),
        pytest.param(
            """\
            + [tool.rapids-build-backend]
            + requires = [
            :            >0
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            :  !0
            """,
            id="rbb-requires",
        ),
        pytest.param(
            """\
            + [project]
            + dependencies = [
            :                >0
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            :  !0
            +
            + [tool.rapids-build-backend]
            + requires = [
            :            >1
            +     "dep-a",
            +     "dep-b",
            + ] # Automatically generated by rapids-dependency-file-generator
            :  !1
            """,
            id="multiple",
        ),
        pytest.param(
            """\
            + [project]
            + license-files = [
            +     "LICENSE",
            + ]
            """,
            id="none",
        ),
    ],
)
def test_get_excluded_sections_pyproject_toml(content):
    content, ranges = parse_named_ranges(content, root_type=list)
    linter = Linter("pyproject.toml", content, "verify-hardcoded-version")
    assert (
        list(hardcoded_version.get_excluded_sections_pyproject_toml(linter))
        == ranges
    )


@pytest.mark.parametrize(
    ["filename", "content"],
    [
        pytest.param(
            "pyproject.toml",
            """\
            + [project]
            + dependencies = [
            :                >0
            +     "dep-a",
            +     "dep-b",
            + ]
            :  !0
            """,
            id="pyproject-toml",
        ),
        pytest.param(
            "python/cudf/pyproject.toml",
            """\
            + [project]
            + dependencies = [
            :                >0
            +     "dep-a",
            +     "dep-b",
            + ]
            :  !0
            """,
            id="sub-pyproject-toml",
        ),
        pytest.param(
            "not-pyproject.toml",
            """\
            + [project]
            + dependencies = [
            +     "dep-a",
            +     "dep-b",
            + ]
            """,
            id="not-pyproject-toml",
        ),
    ],
)
def test_get_excluded_sections(filename, content):
    content, ranges = parse_named_ranges(content, root_type=list)
    linter = Linter(filename, content, "verify-hardcoded-version")
    assert list(hardcoded_version.get_excluded_sections(linter)) == ranges


@pytest.mark.parametrize(
    ["content", "expected_value"],
    [
        pytest.param(
            """\
            + .. deprecated:: 26.02
            +     The `handle` argument was deprecated in 26.02 and will be removed
            +     in 26.04. There's no need to pass in a handle, cuml now manages
            :        ~~~~~match
            +     this resource automatically.
            """,  # noqa: E501
            True,
            id="cuml-handle-deprecation-notice",
        ),
        pytest.param(
            """\
            + This function has a `handle` parameter.
            +
            + .. deprecated:: 26.02
            +     The `handle` argument was deprecated in 26.02 and will be removed
            +     in 26.04. There's no need to pass in a handle, cuml now manages
            :        ~~~~~match
            +     this resource automatically.
            """,  # noqa: E501
            True,
            id="cuml-handle-deprecation-notice-preceding-text",
        ),
        pytest.param(
            """\
            + /**
            +  * @brief Compute the edit distance between all the strings in the input column.
            +  *
            +  * @deprecated Deprecated since release 26.04
            :                                         ~~~~~match
            +  *
            +  * This uses the Levenshtein algorithm to calculate the edit distance between
            +  * two strings as documented here: https://www.cuelogic.com/blog/the-levenshtein-algorithm
            """,  # noqa: E501
            True,
            id="cudf-edit-distance-matrix-deprecation-notice",
        ),
        pytest.param(
            """\
            + * @deprecated Since 26.02
            + */
            + std::string getPackageVersion()
            + {
            +   return "26.04";
            :           ~~~~~match
            + }
            """,
            False,
            id="too-long-after-deprecation-notice",
        ),
        pytest.param(
            """\
            + __version__ = "26.04"
            :                ~~~~~match
            """,
            False,
            id="not-a-deprecation-notice",
        ),
    ],
)
def test_is_deprecation_notice(content, expected_value):
    content, ranges = parse_named_ranges(content)
    match_range = ranges["match"]
    lines = Lines(content)
    match = Mock(
        start=Mock(return_value=match_range[0]),
        end=Mock(return_value=match_range[1]),
    )
    assert (
        hardcoded_version.is_deprecation_notice(lines, match) == expected_value
    )


@pytest.mark.parametrize(
    ["content", "expected_value"],
    [
        pytest.param(
            """\
            + const std::vector<float> boston = {
            +   0.09103, 0,    2.46,  0, 0.488,  7.155, 92.2, 2.7006,  3,  193, 17.8, 394.12, 4.82,  37.9,
            +   0.10008, 0,    2.46,  0, 0.488,  6.563, 95.6, 2.847,   3,  193, 17.8, 396.9,  5.68,  32.5,
            +   0.08308, 0,    2.46,  0, 0.488,  5.604, 89.8, 2.9879,  3,  193, 17.8, 391,    13.98, 26.4,
            :                                                                                        ~~~~match
            +   0.06047, 0,    2.46,  0, 0.488,  6.153, 68.8, 3.2797,  3,  193, 17.8, 387.11, 13.15, 29.6,
            +   0.05602, 0,    2.46,  0, 0.488,  7.831, 53.6, 3.1992,  3,  193, 17.8, 392.63, 4.45,  50};
            """,  # noqa: E501
            True,
            id="cuml-boston",
        ),
        pytest.param(
            """\
            + const std::string VERSION = "26.4";
            :                              ~~~~match
            """,
            False,
            id="not-a-number-array",
        ),
    ],
)
def test_is_number_array(content, expected_value):
    content, ranges = parse_named_ranges(content)
    match_range = ranges["match"]
    lines = Lines(content)
    match = Mock(
        start=Mock(return_value=match_range[0]),
        end=Mock(return_value=match_range[1]),
    )
    assert hardcoded_version.is_number_array(lines, match) == expected_value


@pytest.mark.parametrize(
    ["content", "expected_value"],
    [
        pytest.param(
            """\
            + in 26.04
            :    ~~~~~match
            """,
            True,
            id="in",
        ),
        pytest.param(
            """\
            + since 26.04
            :       ~~~~~match
            """,
            True,
            id="since",
        ),
        pytest.param(
            """\
            + after 26.04
            :       ~~~~~match
            """,
            True,
            id="after",
        ),
        pytest.param(
            """\
            + removed in 26.04
            :            ~~~~~match
            """,
            True,
            id="word-before",
        ),
        pytest.param(
            """\
            + "in 26.04
            :     ~~~~~match
            """,
            True,
            id="quote-before",
        ),
        pytest.param(
            """\
            + in version 26.04
            :            ~~~~~match
            """,
            True,
            id="with-version-word",
        ),
        pytest.param(
            """\
            + In 26.04
            :    ~~~~~match
            """,
            True,
            id="capitalized",
        ),
        pytest.param(
            """\
            + In version 26.04
            :            ~~~~~match
            """,
            True,
            id="capitalized-with-version-word",
        ),
        pytest.param(
            """\
            + 26.04
            : ~~~~~match
            """,
            False,
            id="nothing",
        ),
        pytest.param(
            """\
            + bin 26.04
            :     ~~~~~match
            """,
            False,
            id="wrong-word",
        ),
    ],
)
def test_is_version_doc(content, expected_value):
    content, ranges = parse_named_ranges(content)
    match_range = ranges["match"]
    lines = Lines(content)
    start = Mock(return_value=match_range[0])
    end = Mock(return_value=match_range[1])
    match = Mock(
        start=start,
        end=end,
    )
    assert hardcoded_version.is_version_doc(lines, match) == expected_value
    start.assert_called_once_with("full")


@pytest.mark.parametrize(
    [
        "is_deprecation_notice",
        "is_number_array",
        "is_version_doc",
        "expected_value",
    ],
    [
        pytest.param(
            False,
            False,
            False,
            False,
            id="none",
        ),
        pytest.param(
            True,
            False,
            False,
            True,
            id="is-deprecation-notice",
        ),
        pytest.param(
            False,
            True,
            False,
            True,
            id="is-number-array",
        ),
        pytest.param(
            False,
            False,
            True,
            True,
            id="is-version-doc",
        ),
    ],
)
def test_skip_heuristics(
    is_deprecation_notice, is_number_array, is_version_doc, expected_value
):
    with (
        patch(
            "rapids_pre_commit_hooks.hardcoded_version.is_deprecation_notice",
            Mock(return_value=is_deprecation_notice),
        ),
        patch(
            "rapids_pre_commit_hooks.hardcoded_version.is_number_array",
            Mock(return_value=is_number_array),
        ),
        patch(
            "rapids_pre_commit_hooks.hardcoded_version.is_version_doc",
            Mock(return_value=is_version_doc),
        ),
    ):
        assert (
            hardcoded_version.skip_heuristics(Mock(), Mock()) == expected_value
        )


@pytest.mark.parametrize(
    ["content", "version"],
    [
        pytest.param(
            """\
            > 26.02
            : ~~~~~0.full
            : ~~0.major
            :    ~~0.minor
            """,
            (26, 2, 0),
            id="no-patch-version",
        ),
        pytest.param(
            """\
            > a26.02
            :  ~~~~~0.full
            :  ~~0.major
            :     ~~0.minor
            """,
            (26, 2, 0),
            id="text-before",
        ),
        pytest.param(
            """\
            > 26.02a
            : ~~~~~0.full
            : ~~0.major
            :    ~~0.minor
            """,
            (26, 2, 0),
            id="text-after",
        ),
        pytest.param(
            """\
            > a26.02a
            :  ~~~~~0.full
            :  ~~0.major
            :     ~~0.minor
            """,
            (26, 2, 0),
            id="text-before-and-after",
        ),
        pytest.param(
            """\
            + 26.02
            : ~~~~~0.full
            : ~~0.major
            :    ~~0.minor
            > 26.02
            : ~~~~~1.full
            : ~~1.major
            :    ~~1.minor
            """,
            (26, 2, 0),
            id="multiple-instances",
        ),
        pytest.param(
            """\
            > 26.02.00
            : ~~~~~~~~0.full
            : ~~0.major
            :    ~~0.minor
            :       ~~0.patch
            """,
            (26, 2, 0),
            id="patch-version",
        ),
        pytest.param(
            """\
            > 26.02.01
            """,
            (26, 2, 0),
            id="wrong-patch-version",
        ),
        pytest.param(
            """\
            > 26.04
            """,
            (26, 2, 0),
            id="wrong-major-minor-version",
        ),
        pytest.param(
            """\
            > 0.48
            : ~~~~0.full
            : ~0.major
            :   ~~0.minor
            """,
            (0, 48, 0),
            id="ucxx-version",
        ),
        pytest.param(
            """\
            > 0.48.00
            : ~~~~~~~0.full
            : ~0.major
            :   ~~0.minor
            :      ~~0.patch
            """,
            (0, 48, 0),
            id="ucxx-patch-version",
        ),
        pytest.param(
            """\
            > 026.02
            """,
            (26, 2, 0),
            id="number-before",
        ),
        pytest.param(
            """\
            > 26.020
            """,
            (26, 2, 0),
            id="number-after",
        ),
        pytest.param(
            """\
            > 26.2.0
            : ~~~~~~0.full
            : ~~0.major
            :    ~0.minor
            :      ~0.patch
            """,
            (26, 2, 0),
            id="no-zero-prefix",
        ),
        pytest.param(
            """\
            > 26.2.*
            : ~~~~0.full
            : ~~0.major
            :    ~0.minor
            """,
            (26, 2, 0),
            id="no-zero-prefix-asterisk",
        ),
        pytest.param(
            """\
            > 2026.02.00
            """,
            (26, 2, 0),
            id="4-digit-major",
        ),
        pytest.param(
            """\
            > 26.0002.00
            """,
            (26, 2, 0),
            id="4-digit-minor",
        ),
        pytest.param(
            """\
            > 26.02.0000
            : ~~~~~0.full
            : ~~0.major
            :    ~~0.minor
            """,
            (26, 2, 0),
            id="4-digit-patch",
        ),
    ],
)
def test_find_hardcoded_versions(content, version):
    content, r = parse_named_ranges(content, list)
    assert [
        {group: match.span(group) for group in match.groupdict().keys()}
        for match in hardcoded_version.find_hardcoded_versions(
            content, version
        )
    ] == [{"patch": (-1, -1), **m} for m in r]


@pytest.mark.parametrize(
    ["content", "version", "context"],
    [
        pytest.param(
            "26.02.00\n",
            (26, 2, 0),
            contextlib.nullcontext(),
            id="valid-rapids-version",
        ),
        pytest.param(
            "0.48.00\n",
            (0, 48, 0),
            contextlib.nullcontext(),
            id="valid-ucxx-version",
        ),
        pytest.param(
            "26.02.00",
            None,
            pytest.raises(
                AssertionError,
                match=r'^Expected file ".*/VERSION" to contain ONLY a 3-part '
                r"numeric version, but additional content was found, or no "
                r"trailing newline was found$",
            ),
            id="missing-newline",
        ),
        pytest.param(
            "26.02\n",
            None,
            pytest.raises(
                AssertionError,
                match=r'^Expected file ".*/VERSION" to contain a 3-part '
                r"numeric version, but the patch \(3rd\) part was not found$",
            ),
            id="missing-patch",
        ),
        pytest.param(
            "",
            None,
            pytest.raises(
                AssertionError,
                match=r'Expected file ".*/VERSION" to contain a 3-part '
                r"numeric version, but it was not found$",
            ),
            id="not-version",
        ),
        pytest.param(
            None,
            None,
            pytest.raises(FileNotFoundError),
            id="file-missing",
        ),
    ],
)
def test_read_version_file(tmp_path, content, version, context):
    filename = tmp_path / "VERSION"
    if content is not None:
        with open(filename, "w") as f:
            f.write(content)
    with context:
        assert hardcoded_version.read_version_file(filename) == version


@pytest.mark.parametrize(
    [
        "filename",
        "content",
        "version_file",
        "version",
        "version_file_read",
        "message",
    ],
    [
        pytest.param(
            "file.txt",
            """\
            + RAPIDS 26.02
            :        ~~~~~0
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="version-file",
        ),
        pytest.param(
            "file.txt",
            """\
            + RAPIDS 26.02.00
            :        ~~~~~~~~0
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="version-file-patch-version",
        ),
        pytest.param(
            "file.txt",
            """\
            + RAPIDS 26.02
            :        ~~~~~0
            + RAPIDS 26.02.00
            :        ~~~~~~~~1
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="version-file-multiple",
        ),
        pytest.param(
            "file.txt",
            """\
            + RAPIDS 26.02
            :        ~~~~~0
            """,
            "RAPIDS_VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from RAPIDS_VERSION file instead",
            id="rapids-version-file",
        ),
        pytest.param(
            "file.txt",
            """\
            + RAPIDS 26.04
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="version-not-found",
        ),
        pytest.param(
            "VERSION",
            """\
            + 26.02.00
            """,
            "VERSION",
            (26, 2, 0),
            False,
            "do not hard-code version, read from VERSION file instead",
            id="skip-version-file",
        ),
        pytest.param(
            "pyproject.toml",
            """\
            + [project]
            + version = "26.2.0"
            :            ~~~~~~0
            + dependencies = [
            +     "libcudf-cu12==26.2.*",
            + ]
            + description = "cudf 26.02.00"
            :                     ~~~~~~~~1
            +
            + [tool.rapids-build-backend]
            + requires = [
            +     "libcudf-cu12==26.2.*",
            + ] # Automatically generated by rapids-dependency-file-generator
            + # cudf 26.02.00
            :        ~~~~~~~~2
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="pyproject-toml",
        ),
        pytest.param(
            "file.txt",
            """\
            + .. deprecated:: 26.02
            """,
            "VERSION",
            (26, 2, 0),
            True,
            "do not hard-code version, read from VERSION file instead",
            id="skip-heuristics",
        ),
    ],
)
def test_check_hardcoded_version(
    filename,
    content,
    version_file,
    version,
    version_file_read,
    message,
):
    content, r = parse_named_ranges(content, list)
    linter = Linter(filename, content, "verify-hardcoded-version")
    with patch(
        "rapids_pre_commit_hooks.hardcoded_version.read_version_file",
        Mock(return_value=version),
    ) as mock_read_version_file:
        hardcoded_version.check_hardcoded_version(
            linter, Mock(version_file=version_file)
        )
    if version_file_read:
        mock_read_version_file.assert_called_once_with(version_file)
    else:
        mock_read_version_file.assert_not_called()
    assert linter.warnings == [
        LintWarning(
            m,
            message,
            notes=[
                Note(
                    m,
                    "if this is intentional (as part of a docstring or "
                    "deprecation notice), suppress it with "
                    "rapids-pre-commit-hooks: disable-next-line - see "
                    "https://github.com/rapidsai/pre-commit-hooks/blob/main/"
                    "README.md#suppressing-false-positives for details",
                )
            ],
        )
        for m in r
    ]
